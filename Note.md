**/dist/**: Ignore the dist directory, which is commonly used for build outputs.
**/\*.log: Ignore all .log files.
**/.git/\*\*: Ignore the .git directory, which contains version control metadata.

The usage of double asterisks (\*_) and a single asterisk (_) at the end of glob patterns serves different purposes in specifying file and directory exclusions:

Double Asterisks (**)
Purpose: Matches zero or more directories and subdirectories recursively.
Example: **/node_modules/** matches any directory named node_modules at any level of depth in the directory tree.
Usage: It's used when you want to ignore files and directories that may appear at any level within a specified path.
Single Asterisk (\*)
Purpose: Matches zero or more characters but does not match slashes (/), so it matches only within a single directory level.
Example: **/.\* matches any hidden file or directory (starting with a dot) at any level within the project directory.
Usage: It's typically used to ignore specific files or directories that are located directly within a given directory.
Comparison and Usage
**/node_modules/**:

Matches any directory named node\*modules at any level within the project directory.
Useful for ignoring entire directories and their contents, such as third-party dependencies or large build outputs. \*\*/.\_:

Matches any hidden file or directory (starting with a dot) at any level within the project directory.
Useful for ignoring configuration files (like .gitignore, .eslintrc, etc.) or other hidden files generated by tools and processes.

Common Usage Scenarios
Development Environment:

During development, setting middlewareMode to true allows Vite to dynamically serve assets and handle routing, which is useful for hot module replacement (HMR) and fast development feedback.
Production or Deployment:

In a production environment, middlewareMode might be set to false if you're using a different server (like Express.js, Koa, or another backend framework) to handle requests and serve the built assets generated by Vite.

Vite is configured to run in middleware mode : false (middlewareMode: true in configuration), but Vite cannot display the server URLs (Local and Network) when in this mode. Middleware mode is typically used when integrating Vite into another server environment rather than running it as a standalone server.

#### ESM VS CJS

CommonJS (CJS) and ECMAScript Modules (ESM) are two different module systems in JavaScript used for organizing and structuring code. They have different syntax and behaviors, and they are often used in different contexts. Let's explore each format:

CommonJS (CJS):

1. Synchronous: CommonJS modules are loaded synchronously. When you require a module, it is loaded and executed immediately.
2. Server-Side: CommonJS modules were originally designed for server-side JavaScript (e.g., Node.js). They are commonly used in server-side applications and back-end development.
3. require and module.exports: CommonJS modules use require to import modules and module.exports to export values from a module. For example:

```
 // Importing a module
   const someModule = require('./someModule');

   // Exporting a value
   module.exports = someValue;
```

Single Export Object: CommonJS modules export a single object, which can have multiple properties.

```
module.exports = {
  function1,
  function2,
};
```

ECMAScript Modules (ESM):
Asynchronous: ESM modules can be loaded asynchronously. This allows for better performance, especially in a browser environment.

Client-Side and Server-Side: ESM is designed to work both in client-side (browsers) and server-side (Node.js) environments. Modern JavaScript applications, especially those that run in browsers, often use ESM.

Syntax: ESM uses import to import modules and export to export values from a module.

Example:

```
// Importing a module
import { someFunction } from './someModule.js';

// Exporting a value
export const someValue = 'value';
```

Named and Default Exports: ESM supports named exports and default exports, providing more flexibility.

#### Named Exports Example:

```
// someModule.js
export const function1 = () => {};
export const function2 = () => {};

// Importing named exports
import { function1, function2 } from './someModule.js';

```

### Default Export Example:

```
// someModule.js
const someValue = 'value';
export default someValue;

// Importing default export
import someValue from './someModule.js';
```

Key Differences:
Loading Behavior:

CJS: Synchronous loading. Suitable for environments where synchronous execution is acceptable (e.g., Node.js).
ESM: Asynchronous loading. Better suited for environments where performance and non-blocking behavior are crucial (e.g., browsers).
Environment:

CJS: Primarily used in Node.js environments.
ESM: Designed to work in both browsers and Node.js environments.
Syntax and Export Flexibility:

CJS: Uses require and module.exports. Exports a single object.
ESM: Uses import and export. Supports both named exports and default exports, providing more flexibility.
Tooling and Compatibility:

CJS: Widely supported in Node.js projects. Many existing packages are written in CJS.
ESM: Modern JavaScript applications and tools are increasingly adopting ESM. Browsers natively support ESM, and Node.js has added support for ESM with the .mjs file extension or by setting "type": "module" in package.json.

### Vite Config

`npx vite` is same as `npx vite dev` and same `npx vite serve`

Script: "preview": "vite preview"
Description: Serves the production build locally. This is useful for previewing the production build before deploying it.

Lint:

Script: "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0"
Description: Runs ESLint to lint the codebase, ensuring code quality and consistency.

```
"scripts": {
  "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0"
}
```

### Environmental Variables

In a Node.js environment, such as when using Express for server-side applications, you would use process.env to access environment variables. This is because process.env is the standard way to access environment variables in Node.js.
E.g

`.env`

```
PORT=3000
DATABASE_URL=mongodb://localhost:27017/mydatabase
SECRET_KEY=mysecretkey
```

So we cam use it in `server.js`

```
const express = require('express');
const dotenv = require('dotenv');

// Load environment variables from .env file
dotenv.config();

const app = express();
const port = process.env.PORT || 3000;
const databaseUrl = process.env.DATABASE_URL;
const secretKey = process.env.SECRET_KEY;

app.get('/', (req, res) => {
  res.send('Hello World!');
});

app.listen(port, () => {
  console.log(`Server is running on http://localhost:${port}`);
  console.log(`Connected to database at ${databaseUrl}`);
});
```

In a Vite project, import.meta.env is used to access environment variables instead of process.env for a few reasons specific to the way Vite handles environment variables and how it builds and bundles JavaScript applications. Here's an explanation of why import.meta.env is used instead of process.env:

Why use import.meta.env in Vite:
Bundling and Performance:

Vite is designed to be a fast development server and build tool, and it uses ES modules (ESM) natively. import.meta.env leverages the native ES module system, making it more performant and compatible with Vite's architecture.
Vite optimizes the way environment variables are inlined during the build process. Using import.meta.env allows Vite to replace the variables at build time, resulting in a more optimized and smaller bundle.
Explicit and Scoped:

import.meta.env is a part of the ES module specification and is scoped to the module system, providing a clear and explicit way to handle environment variables in the context of Vite.
This scoping helps avoid potential issues with global variables and ensures that only the necessary environment variables are included in the build.
TypeScript Support:

Vite provides better TypeScript support with import.meta.env, as it can offer type definitions and autocompletion for environment variables defined in a .env file.
Using process.env would require additional setup to achieve similar TypeScript support.
Security and Clarity:

By using import.meta.env, it's easier to distinguish between environment variables intended for the client-side and those for the server-side. Vite can strip out server-side environment variables, reducing the risk of exposing sensitive data to the client.

### Vite and .env

in vite, you dont need to import dotenv, it s automatic. You can save your file as e.g .env, .env.local, .env.development, .env.production, .env.loca.production, .env.local.development

##### Static config

```
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  mode:"production",
  plugins: [react()],
  server: {
    host: "127.0.0.1", // Specify the hostname, "0.0.0.0" makes the server accessible externally. IP addresses the server should listen on
    port: 3000,
    open: true,
    cors: true, // Enable CORS
    strictPort: true, //if true means Exit if the port is already in use (error is shown) but if false vite finds the next available port
    hmr: {
      protocol: "ws", //ws - WebSocket protocol (better for dev and it is default) or wss - WebSocket Secure protocol (better for production)
    },
    watch: {
      ignored: ["**/node_modules/**", "**/dist/**", "**/*.log", "**/.git/**"],
    },
    middlewareMode: false,
  },
});
```

When working with Vite, it's important to understand the purpose of the dist and public directories to decide which one to use for your production build.

dist Directory
Purpose: This directory is generated by Vite when you run the build command (vite build). It contains the optimized and bundled files for your application.
Usage: Use this directory for deployment. All your production-ready code, including HTML, CSS, JavaScript, and any other assets that Vite processes, will be placed here.
Recommendation: You should use the dist directory for your production builds. It is specifically designed for this purpose.
public Directory
Purpose: This directory is used to serve static assets that you want to be available as-is in your project. Files in the public directory are copied to the root of the dist directory without any processing.
Usage: Place static assets like images, favicon, robots.txt, etc., in the public directory. These files will be available in your final build.
Recommendation: Use the public directory for static assets that don't need to be processed by Vite.
How to Structure Your Project
Given your project structure, here’s how you can set it up:

Source Files in src:

All your React components, styles, and other source files should be in the src directory.
Example:
css
Copy code
src/
├── assets/
├── img/
│ └── logo.png
├── pages/
│ └── Notes.jsx
├── App.css
├── App.jsx
├── Main.jsx
└── Index.css
Static Assets in public:

Place any static files that you want to be served directly in the public directory.
Example:
arduino
Copy code
public/
├── favicon.ico
├── robots.txt
└── any-other-static-file.png
Build Configuration:

Vite will process your src files and place the output in the dist directory.
The public directory contents will be copied to the root of the dist directory.

### site.webmanifest

```
The theme_color, background_color, and display properties in the web app manifest (site.webmanifest) control various aspects of how your web application behaves and appears when installed on a user's device. Here's an explanation of each property:

theme_color:

Definition: Specifies the theme color for the application. This affects the color of the address bar and the theme in some browsers when the user adds the app to their home screen.
Usage: It's recommended to set this to a color that matches your application's branding or design scheme. This enhances the user experience by providing a consistent color theme across the browser and the installed application.
Example: "theme_color": "#ffffff" sets the theme color to white. Replace "#ffffff" with the hex code of your desired color.
background_color:

Definition: Specifies the background color of the application's splash screen. This is the color that fills the screen before your application loads.
Usage: Choose a background color that complements your application's design. This provides a seamless transition when launching the app, ensuring a cohesive visual experience.
Example: "background_color": "#ffffff" sets the background color to white. Replace "#ffffff" with the hex code of your desired color.
display:

Definition: Controls how the web application is displayed and launched when installed on the user's device.
Values:
"fullscreen": Opens the web app in fullscreen mode, hiding browser UI elements.
"standalone": Opens the web app as a standalone application, separate from the browser, with its own window and no browser UI elements.
"minimal-ui": Similar to standalone but allows minimal browser UI elements to be shown, such as back/forward buttons.
"browser": Opens the web app in a browser tab or window.
Usage: Choose the appropriate display mode based on your application's design and functionality. For example, if your application is meant to function like a native app with its own interface and no browser controls, "standalone" is appropriate.
Example: "display": "standalone" specifies that the web app should be displayed in standalone mode.
```

````
useEffect(() => {
    console.log("Notes component mounted");

    init();

    return () => {
      console.log("Notes component unmounted");
    };
  }, []);
  ```;
````
